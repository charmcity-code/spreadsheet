import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, o as onMount, v as validate_slots, p as empty, l as insert_dev, n as noop, b as detach_dev, e as element, t as text, f as claim_element, g as children, h as claim_text, j as attr_dev, k as add_location, m as append_dev, r as listen_dev, u as set_data_dev, w as run_all, x as prop_dev, y as validate_each_argument, z as create_component, A as claim_component, B as mount_component, C as transition_in, D as transition_out, E as destroy_component, F as group_outros, G as check_outros, H as destroy_each } from './client.ccecee92.js';

/* src/components/Cell.svelte generated by Svelte v3.24.1 */
const file = "src/components/Cell.svelte";

// (139:2) {:else}
function create_else_block(ctx) {
	let span;
	let t;
	let span_class_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			span = element("span");
			t = text(/*value*/ ctx[0]);
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t = claim_text(span_nodes, /*value*/ ctx[0]);
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", span_class_value = "cell " + (/*selected*/ ctx[3] ? "selected" : "") + " svelte-lcogt");
			add_location(span, file, 140, 4, 3433);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);

			if (!mounted) {
				dispose = [
					listen_dev(span, "click", /*clicked*/ ctx[9], false, false, false),
					listen_dev(span, "dblclick", /*doubleClicked*/ ctx[10], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*value*/ 1) set_data_dev(t, /*value*/ ctx[0]);

			if (dirty & /*selected*/ 8 && span_class_value !== (span_class_value = "cell " + (/*selected*/ ctx[3] ? "selected" : "") + " svelte-lcogt")) {
				attr_dev(span, "class", span_class_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(139:2) {:else}",
		ctx
	});

	return block;
}

// (129:20) 
function create_if_block_2(ctx) {
	let input;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			input = element("input");
			this.h();
		},
		l: function claim(nodes) {
			input = claim_element(nodes, "INPUT", {
				class: true,
				type: true,
				value: true,
				autoFocus: true
			});

			this.h();
		},
		h: function hydrate() {
			attr_dev(input, "class", "cell");
			attr_dev(input, "type", "text");
			input.value = /*value*/ ctx[0];
			input.autofocus = true;
			add_location(input, file, 130, 4, 3228);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
			input.focus();

			if (!mounted) {
				dispose = [
					listen_dev(input, "change", /*onChange*/ ctx[6], false, false, false),
					listen_dev(input, "blur", /*onBlur*/ ctx[7], false, false, false),
					listen_dev(input, "keypress", /*onKeyPressOnInput*/ ctx[8], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*value*/ 1 && input.value !== /*value*/ ctx[0]) {
				prop_dev(input, "value", /*value*/ ctx[0]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(129:20) ",
		ctx
	});

	return block;
}

// (126:2) {#if row === 0}
function create_if_block_1(ctx) {
	let span;
	let t_value = /*alpha*/ ctx[5][/*col*/ ctx[2]] + "";
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(t_value);
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t = claim_text(span_nodes, t_value);
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "cell first-row svelte-lcogt");
			add_location(span, file, 127, 4, 3112);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*col*/ 4 && t_value !== (t_value = /*alpha*/ ctx[5][/*col*/ ctx[2]] + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(126:2) {#if row === 0}",
		ctx
	});

	return block;
}

// (122:0) {#if col === 0}
function create_if_block(ctx) {
	let span;
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(/*row*/ ctx[1]);
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t = claim_text(span_nodes, /*row*/ ctx[1]);
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "cell first-col svelte-lcogt");
			add_location(span, file, 123, 2, 3021);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*row*/ 2) set_data_dev(t, /*row*/ ctx[1]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(122:0) {#if col === 0}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let if_block_anchor;

	function select_block_type(ctx, dirty) {
		if (/*col*/ ctx[2] === 0) return create_if_block;
		if (/*row*/ ctx[1] === 0) return create_if_block_1;
		if (/*editing*/ ctx[4]) return create_if_block_2;
		return create_else_block;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
		},
		p: function update(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

const delay = 200;

function instance($$self, $$props, $$invalidate) {
	let { row } = $$props;
	let { col } = $$props;
	let { value } = $$props;
	let { onChangedValue } = $$props;
	const alpha = (" abcdefghijklmnopqrstuvwxyz").split("");
	let timer = 0;
	let selected = false;
	let prevent = false;
	let editing = false;

	// Emits the `unselectAll` event, used to tell all the other cells to unselect
	const emitUnselectAllEvent = () => {
		const unselectAllEvent = new Event("unselectAll");

		if (typeof window !== "undefined") {
			window.document.dispatchEvent(unselectAllEvent);
		}
	};

	//  Used by `componentDid(Un)Mount`, handles the `unselectAll` event response
	const handleUnselectAll = () => {
		if (selected) {
			$$invalidate(3, selected = false);
		}
	};

	// Lifecycle events
	onMount(() => {
		if (typeof window !== "undefined") {
			window.document.addEventListener("unselectAll", handleUnselectAll);
		}
	});

	// When a Cell value changes, re-determine the display value by calling the formula calculation
	const onChange = event => {
		$$invalidate(0, value = event.target.value);
	};

	/**
 * Called by the `onBlur` or `onKeyPressOnInput` event handlers,
 * it escalates the value changed event, and restore the editing
 * state to `false`.
 */
	const hasNewValue = value => {
		onChangedValue(col, row, value);
		$$invalidate(4, editing = false);
	};

	// Handle moving away from a cell, stores the new value
	const onBlur = event => {
		hasNewValue(event.target.value);
	};

	// Handle pressing a key when the Cell is an input element
	const onKeyPressOnInput = event => {
		if (event.key === "Enter") {
			hasNewValue(event.target.value);
		}
	};

	// Handle clicking a cell
	const clicked = () => {
		// Prevent click and double click to conflict
		timer = setTimeout(
			() => {
				if (!prevent) {
					// Unselect all the other cells and set the current ell state to `selected`
					emitUnselectAllEvent();

					$$invalidate(3, selected = true);
				}

				prevent = false;
			},
			delay
		);
	};

	// Handle doubleclicking a cell
	const doubleClicked = () => {
		// Prevent click and double click to conflict
		clearTimeout(timer);

		prevent = true;

		// Unselect all the other cells and set the current cell state to `selected` & `editing`
		emitUnselectAllEvent();

		$$invalidate(4, editing = true);
		$$invalidate(3, selected = true);
	};

	const writable_props = ["row", "col", "value", "onChangedValue"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Cell> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Cell", $$slots, []);

	$$self.$$set = $$props => {
		if ("row" in $$props) $$invalidate(1, row = $$props.row);
		if ("col" in $$props) $$invalidate(2, col = $$props.col);
		if ("value" in $$props) $$invalidate(0, value = $$props.value);
		if ("onChangedValue" in $$props) $$invalidate(11, onChangedValue = $$props.onChangedValue);
	};

	$$self.$capture_state = () => ({
		onMount,
		row,
		col,
		value,
		onChangedValue,
		alpha,
		delay,
		timer,
		selected,
		prevent,
		editing,
		emitUnselectAllEvent,
		handleUnselectAll,
		onChange,
		hasNewValue,
		onBlur,
		onKeyPressOnInput,
		clicked,
		doubleClicked
	});

	$$self.$inject_state = $$props => {
		if ("row" in $$props) $$invalidate(1, row = $$props.row);
		if ("col" in $$props) $$invalidate(2, col = $$props.col);
		if ("value" in $$props) $$invalidate(0, value = $$props.value);
		if ("onChangedValue" in $$props) $$invalidate(11, onChangedValue = $$props.onChangedValue);
		if ("timer" in $$props) timer = $$props.timer;
		if ("selected" in $$props) $$invalidate(3, selected = $$props.selected);
		if ("prevent" in $$props) prevent = $$props.prevent;
		if ("editing" in $$props) $$invalidate(4, editing = $$props.editing);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		value,
		row,
		col,
		selected,
		editing,
		alpha,
		onChange,
		onBlur,
		onKeyPressOnInput,
		clicked,
		doubleClicked,
		onChangedValue
	];
}

class Cell extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance, create_fragment, safe_not_equal, {
			row: 1,
			col: 2,
			value: 0,
			onChangedValue: 11
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Cell",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*row*/ ctx[1] === undefined && !("row" in props)) {
			console.warn("<Cell> was created without expected prop 'row'");
		}

		if (/*col*/ ctx[2] === undefined && !("col" in props)) {
			console.warn("<Cell> was created without expected prop 'col'");
		}

		if (/*value*/ ctx[0] === undefined && !("value" in props)) {
			console.warn("<Cell> was created without expected prop 'value'");
		}

		if (/*onChangedValue*/ ctx[11] === undefined && !("onChangedValue" in props)) {
			console.warn("<Cell> was created without expected prop 'onChangedValue'");
		}
	}

	get row() {
		throw new Error("<Cell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set row(value) {
		throw new Error("<Cell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get col() {
		throw new Error("<Cell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set col(value) {
		throw new Error("<Cell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<Cell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<Cell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get onChangedValue() {
		throw new Error("<Cell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set onChangedValue(value) {
		throw new Error("<Cell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/Row.svelte generated by Svelte v3.24.1 */
const file$1 = "src/components/Row.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[4] = list[i];
	child_ctx[6] = i;
	return child_ctx;
}

// (17:2) {#each Array(cols) as _, col}
function create_each_block(ctx) {
	let cell;
	let current;

	cell = new Cell({
			props: {
				row: /*row*/ ctx[1],
				col: /*col*/ ctx[6],
				value: /*rowData*/ ctx[2][/*col*/ ctx[6]] || "",
				onChangedValue: /*handleChangedCell*/ ctx[3]
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(cell.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(cell.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(cell, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const cell_changes = {};
			if (dirty & /*row*/ 2) cell_changes.row = /*row*/ ctx[1];
			if (dirty & /*rowData*/ 4) cell_changes.value = /*rowData*/ ctx[2][/*col*/ ctx[6]] || "";
			if (dirty & /*handleChangedCell*/ 8) cell_changes.onChangedValue = /*handleChangedCell*/ ctx[3];
			cell.$set(cell_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(cell.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(cell.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(cell, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(17:2) {#each Array(cols) as _, col}",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let div;
	let current;
	let each_value = Array(/*cols*/ ctx[0]);
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div_nodes);
			}

			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "row svelte-14wbpsf");
			add_location(div, file$1, 15, 0, 199);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*row, rowData, handleChangedCell, cols*/ 15) {
				each_value = Array(/*cols*/ ctx[0]);
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(div, null);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	let { cols } = $$props;
	let { row } = $$props;
	let { rowData } = $$props;
	let { handleChangedCell } = $$props;
	const writable_props = ["cols", "row", "rowData", "handleChangedCell"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Row> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Row", $$slots, []);

	$$self.$$set = $$props => {
		if ("cols" in $$props) $$invalidate(0, cols = $$props.cols);
		if ("row" in $$props) $$invalidate(1, row = $$props.row);
		if ("rowData" in $$props) $$invalidate(2, rowData = $$props.rowData);
		if ("handleChangedCell" in $$props) $$invalidate(3, handleChangedCell = $$props.handleChangedCell);
	};

	$$self.$capture_state = () => ({
		Cell,
		cols,
		row,
		rowData,
		handleChangedCell
	});

	$$self.$inject_state = $$props => {
		if ("cols" in $$props) $$invalidate(0, cols = $$props.cols);
		if ("row" in $$props) $$invalidate(1, row = $$props.row);
		if ("rowData" in $$props) $$invalidate(2, rowData = $$props.rowData);
		if ("handleChangedCell" in $$props) $$invalidate(3, handleChangedCell = $$props.handleChangedCell);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [cols, row, rowData, handleChangedCell];
}

class Row extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1, create_fragment$1, safe_not_equal, {
			cols: 0,
			row: 1,
			rowData: 2,
			handleChangedCell: 3
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Row",
			options,
			id: create_fragment$1.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*cols*/ ctx[0] === undefined && !("cols" in props)) {
			console.warn("<Row> was created without expected prop 'cols'");
		}

		if (/*row*/ ctx[1] === undefined && !("row" in props)) {
			console.warn("<Row> was created without expected prop 'row'");
		}

		if (/*rowData*/ ctx[2] === undefined && !("rowData" in props)) {
			console.warn("<Row> was created without expected prop 'rowData'");
		}

		if (/*handleChangedCell*/ ctx[3] === undefined && !("handleChangedCell" in props)) {
			console.warn("<Row> was created without expected prop 'handleChangedCell'");
		}
	}

	get cols() {
		throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set cols(value) {
		throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get row() {
		throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set row(value) {
		throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get rowData() {
		throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set rowData(value) {
		throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get handleChangedCell() {
		throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set handleChangedCell(value) {
		throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/Table.svelte generated by Svelte v3.24.1 */

function get_each_context$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[5] = list[i];
	child_ctx[7] = i;
	return child_ctx;
}

// (30:0) {#each Array(rows) as _, row}
function create_each_block$1(ctx) {
	let row_1;
	let current;

	row_1 = new Row({
			props: {
				row: /*row*/ ctx[7],
				cols: /*cols*/ ctx[1],
				rowData: /*data*/ ctx[0][/*row*/ ctx[7]] || {},
				handleChangedCell: /*handleChangedCell*/ ctx[3]
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(row_1.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(row_1.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(row_1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const row_1_changes = {};
			if (dirty & /*data*/ 1) row_1_changes.rowData = /*data*/ ctx[0][/*row*/ ctx[7]] || {};
			row_1.$set(row_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(row_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(row_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(row_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$1.name,
		type: "each",
		source: "(30:0) {#each Array(rows) as _, row}",
		ctx
	});

	return block;
}

function create_fragment$2(ctx) {
	let each_1_anchor;
	let current;
	let each_value = Array(/*rows*/ ctx[2]);
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*cols, data, handleChangedCell*/ 11) {
				each_value = Array(/*rows*/ ctx[2]);
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$1(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$1(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2($$self, $$props, $$invalidate) {
	let cols = 8;
	let rows = 15;
	let data = {};
	let { tableIdentifier } = $$props;

	onMount(() => {
		if (typeof window !== "undefined") {
			const localStorageData = window.localStorage.getItem(tableIdentifier);

			if (localStorageData) {
				$$invalidate(0, data = JSON.parse(localStorageData));
			}
		}
	});

	const handleChangedCell = (col, row, value) => {
		if (!data[row]) $$invalidate(0, data[row] = {}, data);
		$$invalidate(0, data[row][col] = value, data);

		if (window && window.localStorage) {
			window.localStorage.setItem(tableIdentifier, JSON.stringify(data));
		}
	};

	const writable_props = ["tableIdentifier"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Table> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Table", $$slots, []);

	$$self.$$set = $$props => {
		if ("tableIdentifier" in $$props) $$invalidate(4, tableIdentifier = $$props.tableIdentifier);
	};

	$$self.$capture_state = () => ({
		onMount,
		Row,
		cols,
		rows,
		data,
		tableIdentifier,
		handleChangedCell
	});

	$$self.$inject_state = $$props => {
		if ("cols" in $$props) $$invalidate(1, cols = $$props.cols);
		if ("rows" in $$props) $$invalidate(2, rows = $$props.rows);
		if ("data" in $$props) $$invalidate(0, data = $$props.data);
		if ("tableIdentifier" in $$props) $$invalidate(4, tableIdentifier = $$props.tableIdentifier);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [data, cols, rows, handleChangedCell, tableIdentifier];
}

class Table extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2, create_fragment$2, safe_not_equal, { tableIdentifier: 4 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Table",
			options,
			id: create_fragment$2.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*tableIdentifier*/ ctx[4] === undefined && !("tableIdentifier" in props)) {
			console.warn("<Table> was created without expected prop 'tableIdentifier'");
		}
	}

	get tableIdentifier() {
		throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tableIdentifier(value) {
		throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/spreadsheets/[id].svelte generated by Svelte v3.24.1 */

function create_fragment$3(ctx) {
	let table;
	let current;

	table = new Table({
			props: { tableIdentifier: /*id*/ ctx[0] },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(table.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(table.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(table, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const table_changes = {};
			if (dirty & /*id*/ 1) table_changes.tableIdentifier = /*id*/ ctx[0];
			table.$set(table_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(table.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(table.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(table, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

async function preload({ params }) {
	const { id } = params;
	return { id };
}

function instance$3($$self, $$props, $$invalidate) {
	let { id } = $$props;
	const writable_props = ["id"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<U5Bidu5D> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("U5Bidu5D", $$slots, []);

	$$self.$$set = $$props => {
		if ("id" in $$props) $$invalidate(0, id = $$props.id);
	};

	$$self.$capture_state = () => ({ preload, id, Table });

	$$self.$inject_state = $$props => {
		if ("id" in $$props) $$invalidate(0, id = $$props.id);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [id];
}

class U5Bidu5D extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3, create_fragment$3, safe_not_equal, { id: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "U5Bidu5D",
			options,
			id: create_fragment$3.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*id*/ ctx[0] === undefined && !("id" in props)) {
			console.warn("<U5Bidu5D> was created without expected prop 'id'");
		}
	}

	get id() {
		throw new Error("<U5Bidu5D>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<U5Bidu5D>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default U5Bidu5D;
export { preload };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiW2lkXS5iODNiZWUyMy5qcyIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvQ2VsbC5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy9Sb3cuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvVGFibGUuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL3JvdXRlcy9zcHJlYWRzaGVldHMvW2lkXS5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPHNjcmlwdD5cbiAgaW1wb3J0IHsgb25Nb3VudCB9IGZyb20gXCJzdmVsdGVcIjtcbiAgZXhwb3J0IGxldCByb3c7XG4gIGV4cG9ydCBsZXQgY29sO1xuICBleHBvcnQgbGV0IHZhbHVlO1xuICBleHBvcnQgbGV0IG9uQ2hhbmdlZFZhbHVlO1xuXG4gIGNvbnN0IGFscGhhID0gXCIgYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcIi5zcGxpdChcIlwiKTtcbiAgY29uc3QgZGVsYXkgPSAyMDA7XG4gIGxldCB0aW1lciA9IDA7XG4gIGxldCBzZWxlY3RlZCA9IGZhbHNlO1xuICBsZXQgcHJldmVudCA9IGZhbHNlO1xuICBsZXQgZWRpdGluZyA9IGZhbHNlO1xuXG4gIC8vIEVtaXRzIHRoZSBgdW5zZWxlY3RBbGxgIGV2ZW50LCB1c2VkIHRvIHRlbGwgYWxsIHRoZSBvdGhlciBjZWxscyB0byB1bnNlbGVjdFxuICBjb25zdCBlbWl0VW5zZWxlY3RBbGxFdmVudCA9ICgpID0+IHtcbiAgICBjb25zdCB1bnNlbGVjdEFsbEV2ZW50ID0gbmV3IEV2ZW50KFwidW5zZWxlY3RBbGxcIik7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHdpbmRvdy5kb2N1bWVudC5kaXNwYXRjaEV2ZW50KHVuc2VsZWN0QWxsRXZlbnQpO1xuICAgIH1cbiAgfTtcblxuICAvLyAgVXNlZCBieSBgY29tcG9uZW50RGlkKFVuKU1vdW50YCwgaGFuZGxlcyB0aGUgYHVuc2VsZWN0QWxsYCBldmVudCByZXNwb25zZVxuICBjb25zdCBoYW5kbGVVbnNlbGVjdEFsbCA9ICgpID0+IHtcbiAgICBpZiAoc2VsZWN0ZWQpIHtcbiAgICAgIHNlbGVjdGVkID0gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIC8vIExpZmVjeWNsZSBldmVudHNcbiAgb25Nb3VudCgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHdpbmRvdy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwidW5zZWxlY3RBbGxcIiwgaGFuZGxlVW5zZWxlY3RBbGwpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gV2hlbiBhIENlbGwgdmFsdWUgY2hhbmdlcywgcmUtZGV0ZXJtaW5lIHRoZSBkaXNwbGF5IHZhbHVlIGJ5IGNhbGxpbmcgdGhlIGZvcm11bGEgY2FsY3VsYXRpb25cbiAgY29uc3Qgb25DaGFuZ2UgPSBldmVudCA9PiB7XG4gICAgdmFsdWUgPSBldmVudC50YXJnZXQudmFsdWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIENhbGxlZCBieSB0aGUgYG9uQmx1cmAgb3IgYG9uS2V5UHJlc3NPbklucHV0YCBldmVudCBoYW5kbGVycyxcbiAgICogaXQgZXNjYWxhdGVzIHRoZSB2YWx1ZSBjaGFuZ2VkIGV2ZW50LCBhbmQgcmVzdG9yZSB0aGUgZWRpdGluZ1xuICAgKiBzdGF0ZSB0byBgZmFsc2VgLlxuICAgKi9cbiAgY29uc3QgaGFzTmV3VmFsdWUgPSB2YWx1ZSA9PiB7XG4gICAgb25DaGFuZ2VkVmFsdWUoY29sLCByb3csIHZhbHVlKTtcbiAgICBlZGl0aW5nID0gZmFsc2U7XG4gIH07XG5cbiAgLy8gSGFuZGxlIG1vdmluZyBhd2F5IGZyb20gYSBjZWxsLCBzdG9yZXMgdGhlIG5ldyB2YWx1ZVxuICBjb25zdCBvbkJsdXIgPSBldmVudCA9PiB7XG4gICAgaGFzTmV3VmFsdWUoZXZlbnQudGFyZ2V0LnZhbHVlKTtcbiAgfTtcblxuICAvLyBIYW5kbGUgcHJlc3NpbmcgYSBrZXkgd2hlbiB0aGUgQ2VsbCBpcyBhbiBpbnB1dCBlbGVtZW50XG4gIGNvbnN0IG9uS2V5UHJlc3NPbklucHV0ID0gZXZlbnQgPT4ge1xuICAgIGlmIChldmVudC5rZXkgPT09IFwiRW50ZXJcIikge1xuICAgICAgaGFzTmV3VmFsdWUoZXZlbnQudGFyZ2V0LnZhbHVlKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gSGFuZGxlIGNsaWNraW5nIGEgY2VsbFxuICBjb25zdCBjbGlja2VkID0gKCkgPT4ge1xuICAgIC8vIFByZXZlbnQgY2xpY2sgYW5kIGRvdWJsZSBjbGljayB0byBjb25mbGljdFxuICAgIHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAoIXByZXZlbnQpIHtcbiAgICAgICAgLy8gVW5zZWxlY3QgYWxsIHRoZSBvdGhlciBjZWxscyBhbmQgc2V0IHRoZSBjdXJyZW50IGVsbCBzdGF0ZSB0byBgc2VsZWN0ZWRgXG4gICAgICAgIGVtaXRVbnNlbGVjdEFsbEV2ZW50KCk7XG4gICAgICAgIHNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHByZXZlbnQgPSBmYWxzZTtcbiAgICB9LCBkZWxheSk7XG4gIH07XG5cbiAgLy8gSGFuZGxlIGRvdWJsZWNsaWNraW5nIGEgY2VsbFxuICBjb25zdCBkb3VibGVDbGlja2VkID0gKCkgPT4ge1xuICAgIC8vIFByZXZlbnQgY2xpY2sgYW5kIGRvdWJsZSBjbGljayB0byBjb25mbGljdFxuICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgcHJldmVudCA9IHRydWU7XG5cbiAgICAvLyBVbnNlbGVjdCBhbGwgdGhlIG90aGVyIGNlbGxzIGFuZCBzZXQgdGhlIGN1cnJlbnQgY2VsbCBzdGF0ZSB0byBgc2VsZWN0ZWRgICYgYGVkaXRpbmdgXG4gICAgZW1pdFVuc2VsZWN0QWxsRXZlbnQoKTtcbiAgICBlZGl0aW5nID0gdHJ1ZTtcbiAgICBzZWxlY3RlZCA9IHRydWU7XG4gIH07XG48L3NjcmlwdD5cblxuPHN0eWxlPlxuICBzcGFuLmNlbGwge1xuICAgIHdpZHRoOiA4MHB4O1xuICAgIHBhZGRpbmc6IDRweDtcbiAgICBtYXJnaW46IDA7XG4gICAgaGVpZ2h0OiAyNXB4O1xuICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICBjb2xvcjogYmxhY2s7XG4gICAgYm9yZGVyOiAxcHggc29saWQgI2NhY2FjYTtcbiAgICB0ZXh0LWFsaWduOiBsZWZ0O1xuICAgIHZlcnRpY2FsLWFsaWduOiB0b3A7XG4gICAgZm9udC1zaXplOiAxNHB4O1xuICAgIGxpbmUtaGVpZ2h0OiAxNXB4O1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgZm9udC1mYW1pbHk6IENhbGlicmksIFNlZ29lIFVJLCBUaG9uYnVyaSwgQXJpYWwsIFZlcmRhbmEsIHNhbnMtc2VyaWY7XG4gIH1cblxuICBzcGFuLmNlbGwuZmlyc3Qtcm93LFxuICBzcGFuLmNlbGwuZmlyc3QtY29sIHtcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2YwZjBmMDtcbiAgICBmb250LXdlaWdodDogYm9sZDtcbiAgfVxuXG4gIHNwYW4uY2VsbC5zZWxlY3RlZCB7XG4gICAgb3V0bGluZS1jb2xvcjogYmx1ZTtcbiAgICBvdXRsaW5lLXN0eWxlOiBzb2xpZDtcbiAgfVxuPC9zdHlsZT5cblxueyNpZiBjb2wgPT09IDB9XG4gIDwhLS0gY29sdW1uIDAgLS0+XG4gIDxzcGFuIGNsYXNzPVwiY2VsbCBmaXJzdC1jb2xcIj57cm93fTwvc3Bhbj5cbns6ZWxzZX1cbiAgeyNpZiByb3cgPT09IDB9XG4gICAgPCEtLSByb3cgMCAtLT5cbiAgICA8c3BhbiBjbGFzcz1cImNlbGwgZmlyc3Qtcm93XCI+e2FscGhhW2NvbF19PC9zcGFuPlxuICB7OmVsc2UgaWYgZWRpdGluZ31cbiAgICA8IS0tIHN2ZWx0ZS1pZ25vcmUgYTExeS1hdXRvZm9jdXMgLS0+XG4gICAgPGlucHV0XG4gICAgICBjbGFzcz1cImNlbGxcIlxuICAgICAgdHlwZT1cInRleHRcIlxuICAgICAge3ZhbHVlfVxuICAgICAgb246Y2hhbmdlPXtvbkNoYW5nZX1cbiAgICAgIG9uOmJsdXI9e29uQmx1cn1cbiAgICAgIG9uOmtleXByZXNzPXtvbktleVByZXNzT25JbnB1dH1cbiAgICAgIGF1dG9Gb2N1cyAvPlxuICB7OmVsc2V9XG4gICAgPCEtLSByZWd1bGFyIGNlbGwgLS0+XG4gICAgPHNwYW5cbiAgICAgIGNsYXNzPVwiY2VsbCB7c2VsZWN0ZWQgPyAnc2VsZWN0ZWQnIDogJyd9XCJcbiAgICAgIG9uOmNsaWNrPXtjbGlja2VkfVxuICAgICAgb246ZGJsY2xpY2s9e2RvdWJsZUNsaWNrZWR9PlxuICAgICAge3ZhbHVlfVxuICAgIDwvc3Bhbj5cbiAgey9pZn1cbnsvaWZ9XG4iLCI8c2NyaXB0PlxuICBpbXBvcnQgQ2VsbCBmcm9tIFwiLi9DZWxsLnN2ZWx0ZVwiO1xuXG4gIGV4cG9ydCBsZXQgY29scztcbiAgZXhwb3J0IGxldCByb3c7XG4gIGV4cG9ydCBsZXQgcm93RGF0YTtcbiAgZXhwb3J0IGxldCBoYW5kbGVDaGFuZ2VkQ2VsbDtcbjwvc2NyaXB0PlxuXG48c3R5bGU+XG4gIC5yb3cge1xuICAgIGRpc3BsYXk6IGJsb2NrO1xuICB9XG48L3N0eWxlPlxuXG48ZGl2IGNsYXNzPVwicm93XCI+XG4gIHsjZWFjaCBBcnJheShjb2xzKSBhcyBfLCBjb2x9XG4gICAgPENlbGxcbiAgICAgIHtyb3d9XG4gICAgICB7Y29sfVxuICAgICAgdmFsdWU9e3Jvd0RhdGFbY29sXSB8fCAnJ31cbiAgICAgIG9uQ2hhbmdlZFZhbHVlPXtoYW5kbGVDaGFuZ2VkQ2VsbH0gLz5cbiAgey9lYWNofVxuPC9kaXY+XG4iLCI8c2NyaXB0PlxuICBpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiO1xuICBpbXBvcnQgUm93IGZyb20gXCIuL1Jvdy5zdmVsdGVcIjtcblxuICBsZXQgY29scyA9IDg7XG4gIGxldCByb3dzID0gMTU7XG4gIGxldCBkYXRhID0ge307XG5cbiAgZXhwb3J0IGxldCB0YWJsZUlkZW50aWZpZXI7XG5cbiAgb25Nb3VudCgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGNvbnN0IGxvY2FsU3RvcmFnZURhdGEgPSB3aW5kb3cubG9jYWxTdG9yYWdlLmdldEl0ZW0odGFibGVJZGVudGlmaWVyKTtcbiAgICAgIGlmIChsb2NhbFN0b3JhZ2VEYXRhKSB7XG4gICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZURhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgY29uc3QgaGFuZGxlQ2hhbmdlZENlbGwgPSAoY29sLCByb3csIHZhbHVlKSA9PiB7XG4gICAgaWYgKCFkYXRhW3Jvd10pIGRhdGFbcm93XSA9IHt9O1xuICAgIGRhdGFbcm93XVtjb2xdID0gdmFsdWU7XG5cbiAgICBpZiAod2luZG93ICYmIHdpbmRvdy5sb2NhbFN0b3JhZ2UpIHtcbiAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbSh0YWJsZUlkZW50aWZpZXIsIEpTT04uc3RyaW5naWZ5KGRhdGEpKTtcbiAgICB9XG4gIH07XG48L3NjcmlwdD5cblxueyNlYWNoIEFycmF5KHJvd3MpIGFzIF8sIHJvd31cbiAgPFJvdyB7cm93fSB7Y29sc30gcm93RGF0YT17ZGF0YVtyb3ddIHx8IHt9fSB7aGFuZGxlQ2hhbmdlZENlbGx9IC8+XG57L2VhY2h9XG4iLCI8c2NyaXB0IGNvbnRleHQ9XCJtb2R1bGVcIj5cbiAgZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByZWxvYWQoeyBwYXJhbXMgfSkge1xuICAgIGNvbnN0IHsgaWQgfSA9IHBhcmFtcztcbiAgICByZXR1cm4geyBpZCB9O1xuICB9XG48L3NjcmlwdD5cblxuPHNjcmlwdD5cbiAgZXhwb3J0IGxldCBpZDtcbiAgaW1wb3J0IFRhYmxlIGZyb20gXCIuLi8uLi9jb21wb25lbnRzL1RhYmxlLnN2ZWx0ZVwiO1xuPC9zY3JpcHQ+XG5cbjxUYWJsZSB0YWJsZUlkZW50aWZpZXI9e2lkfSAvPlxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7c0JBZ0pPLEdBQUs7Ozs7Ozt3Q0FBTCxHQUFLOzs7OztzRUFITyxHQUFRLE1BQUcsVUFBVSxHQUFHLEVBQUU7Ozs7Ozs7OzsyQ0FDN0IsR0FBTztvREFDSixHQUFhOzs7Ozs7O3NEQUN6QixHQUFLOztrR0FITyxHQUFRLE1BQUcsVUFBVSxHQUFHLEVBQUU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzhDQVA1QixHQUFROzBDQUNWLEdBQU07eURBQ0YsR0FBaUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3lCQVRGLEdBQUssWUFBQyxHQUFHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzZEQUFULEdBQUssWUFBQyxHQUFHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFKWCxHQUFHOzs7Ozs7c0NBQUgsR0FBRzs7Ozs7Ozs7Ozs7OztrREFBSCxHQUFHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2NBRjlCLEdBQUcsUUFBSyxDQUFDO2NBSVAsR0FBRyxRQUFLLENBQUM7a0JBR0osR0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztNQXhIWCxLQUFLLEdBQUcsR0FBRzs7O09BTk4sR0FBRztPQUNILEdBQUc7T0FDSCxLQUFLO09BQ0wsY0FBYztPQUVuQixLQUFLLElBQUcsNkJBQTZCLEVBQUMsS0FBSyxDQUFDLEVBQUU7S0FFaEQsS0FBSyxHQUFHLENBQUM7S0FDVCxRQUFRLEdBQUcsS0FBSztLQUNoQixPQUFPLEdBQUcsS0FBSztLQUNmLE9BQU8sR0FBRyxLQUFLOzs7T0FHYixvQkFBb0I7UUFDbEIsZ0JBQWdCLE9BQU8sS0FBSyxDQUFDLGFBQWE7O2FBQ3JDLE1BQU0sS0FBSyxXQUFXO0dB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
